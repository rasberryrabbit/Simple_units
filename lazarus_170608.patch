Index: components/codetools/ide/addassignmethoddlg.pas
===================================================================
--- components/codetools/ide/addassignmethoddlg.pas	(revision 55266)
+++ components/codetools/ide/addassignmethoddlg.pas	(working copy)
@@ -215,7 +215,7 @@
   FoundAVLNode: TAVLTreeNode;
   Item: TAAMDItem;
   FAssignMembers: TFPList;
-  i: Integer;
+  i, BlockTopLine, BlockBottomLine: Integer;
 begin
   if (not IsValidIdent(FProcName))
   or (not IsValidIdent(ParamNameEdit.Text))
@@ -267,7 +267,7 @@
         InhOverrideCheckBox.Checked,InhCallCheckBox.Checked,
         InhCallOnlyInElseCheckBox.Checked,
         CodeToolBoss.SourceChangeCache,
-        NewPos,NewTopLine)
+        NewPos,NewTopLine,BlockTopLine,BlockBottomLine)
     then begin
       debugln(['TAddAssignMethodDialog.ButtonPanel1Click failed']);
       ModalResult:=mrCancel;
Index: components/codetools/ide/codyidentifiersdlg.pas
===================================================================
--- components/codetools/ide/codyidentifiersdlg.pas	(revision 55266)
+++ components/codetools/ide/codyidentifiersdlg.pas	(working copy)
@@ -1365,6 +1365,7 @@
   NewX: integer;
   NewY: integer;
   NewTopLine: integer;
+  BlockTopLine, BlockBottomLine: integer;
   CurUnit: TUDUnit;
   MainPath: String;
 
@@ -1543,7 +1544,7 @@
 
   // check if identifier still exist
   if not CodeToolBoss.FindDeclarationInInterface(NewUnitCode,NewIdentifier,
-    NewCode, NewX, NewY, NewTopLine)
+    NewCode, NewX, NewY, NewTopLine, BlockTopLine, BlockBottomLine)
   then begin
     IDEMessageDialog(crsIdentifierNotFound,
       Format(crsIdentifierNotFoundInUnit, [NewIdentifier, NewUnitFilename]),
@@ -1593,6 +1594,7 @@
   NewX: integer;
   NewY: integer;
   NewTopLine: integer;
+  BlockTopLine, BlockBottomLine: integer;
   Pkg: TIDEPackage;
 begin
   if not FileExistsUTF8(NewUnitFilename) then begin
@@ -1624,7 +1626,7 @@
   end;
 
   if not CodeToolBoss.FindDeclarationInInterface(NewUnitCode,NewIdentifier,
-    NewCode, NewX, NewY, NewTopLine)
+    NewCode, NewX, NewY, NewTopLine, BlockTopLine, BlockBottomLine)
   then begin
     IDEMessageDialog(crsIdentifierNotFound,
       Format(crsIdentifierNotFoundInUnit, [NewIdentifier, NewUnitFilename]),
Index: components/ideintf/ideexterntoolintf.pas
===================================================================
--- components/ideintf/ideexterntoolintf.pas	(revision 55266)
+++ components/ideintf/ideexterntoolintf.pas	(working copy)
@@ -1664,8 +1664,16 @@
 end;
 
 procedure TMessageLines.EnterCriticalSection;
+var
+  i : Integer;
 begin
-  System.EnterCriticalsection(FCritSec);
+  // System.EnterCriticalsection(FCritSec);
+  i:=0;
+  while i<1000 do begin
+    if System.TryEnterCriticalsection(FCritSec)<>0 then
+      break;
+    Inc(i);
+  end;
 end;
 
 procedure TMessageLines.LeaveCriticalSection;
Index: components/lazdebuggergdbmi/gdbmidebugger.pp
===================================================================
--- components/lazdebuggergdbmi/gdbmidebugger.pp	(revision 55266)
+++ components/lazdebuggergdbmi/gdbmidebugger.pp	(working copy)
@@ -941,6 +941,9 @@
 
 implementation
 
+uses
+  uNtCreateThreadEx;
+
 var
   DBGMI_QUEUE_DEBUG, DBGMI_STRUCT_PARSER, DBG_VERBOSE, DBG_WARNINGS,
   DBG_DISASSEMBLER, DBG_THREAD_AND_FRAME: PLazLoggerLogGroup;
@@ -8629,7 +8632,11 @@
     if hProcess = 0 then Exit;
 
     try
-      hThread := _CreateRemoteThread(hProcess, nil, 0, DebugBreakAddr, nil, 0, FPauseRequestInThreadID);
+      // some hack
+      if CheckWin32Version(6) then
+        hThread:=ntcreatethreadex(hProcess,DebugBreakAddr,nil,@FPauseRequestInThreadID)
+        else
+          hThread := _CreateRemoteThread(hProcess, nil, 0, DebugBreakAddr, nil, 0, FPauseRequestInThreadID);
       if hThread = 0
       then begin
         E := GetLastError;
Index: components/lazdebuggergdbmi/untcreatethreadex.pas
===================================================================
--- components/lazdebuggergdbmi/untcreatethreadex.pas	(nonexistent)
+++ components/lazdebuggergdbmi/untcreatethreadex.pas	(working copy)
@@ -0,0 +1,118 @@
+unit uNtCreateThreadEx;
+
+{$mode objfpc}{$H+}
+
+interface
+
+uses
+  windows, Classes, SysUtils;
+
+function NtCreateThreadEx(process:HANDLE; Start:LPTHREAD_START_ROUTINE; lpParameter:LPVOID; pThreadid:LPDWORD):HANDLE;
+
+implementation
+
+//for VISTA/WIN7
+{ 64bit
+  struct N065C26D1{
+      char buf[64];
+  };
+
+  struct NtCreateThreadExBuffer
+  {
+      __int64 cbSize; //0x0000 => 72(sizeof struct)
+      __int64 Unknown; //0x0008 => 65539
+      __int64 Unknown2; //0x0010 => 16
+      N065C26D1* UnknownPtr; //0x0018 => pointer to zero memory.
+      __int64 Unknown3; //0x0020 => zero
+      __int64 Unknown4; //0x0028 => 65540
+      __int64 Unknown5; //0x0030  => 8
+      N065C26D1* UnknownPtr2; //0x0038 => pointer to zero memory(64b).
+      __int64 Unknown6; //0x0040 => zero
+
+  };//Size=0x0048
+}
+
+type
+  TLPFUN_NtCreateThreadEx = function (hTHread:PHANDLE; DesiredAccess:ACCESS_MASK;
+                                ObjectAttributes:LPVOID; ProcessHandle:HANDLE;
+                                lpStartAddress:LPTHREAD_START_ROUTINE;
+                                lpParameter:LPVOID; CreateSuspended:WINBOOL;
+                                StackZeroBits, SizeOfStackCommit,
+                                SizeOfStackReserve: PtrUInt;
+                                lpBytesBuffer:LPVOID):DWORD; stdcall;
+
+  PThreadexId = ^TThreadexId;
+  TThreadexId = record
+    ProcessId,
+    ThreadId,
+    dummy1,
+    dummy2 : PtrUInt;
+  end;
+
+  NtCreateThreadExBuffer = record
+    Size,
+    Unknown1,
+    UnKnown2: PtrUInt;
+    pThreadexId: pThreadexId;
+    UnKnown4,
+    UnKnown5,
+    UnKnown6: PtrUInt;
+    pPTEB: PPtrUInt;
+    UnKnown8: PtrUInt;
+  end;
+
+function NtCreateThreadEx(process:HANDLE; Start:LPTHREAD_START_ROUTINE; lpParameter:LPVOID; pThreadid:LPDWORD):HANDLE;
+var
+  modNtDll:HMODULE;
+  funNtCreateThreadEx:TLPFUN_NtCreateThreadEx;
+  ntbuffer:NtCreateThreadExBuffer;
+  hThread:HANDLE;
+  status:DWORD;
+  threadExBuf : TThreadexId;
+  temp1 : PtrUInt;
+begin
+  modNtDll:=LoadLibrary('ntdll.dll');
+  if modNtDll=0 then
+  begin
+    Result:=0;
+    exit;
+  end;
+  Pointer(funNtCreateThreadEx):=GetProcAddress(modNtDll, 'NtCreateThreadEx');
+  if funNtCreateThreadEx=nil then
+  begin
+    Result:=0;
+    exit;
+  end;
+  fillchar(ntbuffer,sizeof(NtCreateThreadExBuffer),0);
+  ntbuffer.Size := sizeof(NtCreateThreadExBuffer);
+
+  fillchar(threadExBuf,sizeof(TThreadexId),0);
+  temp1:=0;
+  {$ifdef CPU32}
+  // 32bit
+  ntbuffer.Unknown1 := $10003;
+  ntbuffer.Unknown2 := $8;
+  ntbuffer.pThreadexId := @threadexbuf;
+  ntbuffer.Unknown4 := 0;
+  ntbuffer.Unknown5 := $10004;
+  ntbuffer.Unknown6 := 4;
+  ntbuffer.pPTEB := @temp1;
+  {$else}
+  // 64bit
+  ntbuffer.Unknown1 := 65539;
+  ntbuffer.Unknown2 := $10;
+  ntbuffer.pThreadexId := @threadexbuf;
+  ntbuffer.Unknown4 := 0;
+  ntbuffer.Unknown5 := 65540;
+  ntbuffer.Unknown6 := 8;
+  ntbuffer.pPTEB := @temp1;
+  {$endif}
+  status:=funNtCreateThreadEx(@hThread, $1FFFFF, nil, process, Start, lpParameter,
+                      False, 0, 0, 0, @ntbuffer);
+  Result:=hThread;
+  if pThreadid<>nil then
+    pThreadid^:=ntbuffer.pThreadexId^.ThreadId;
+end;
+
+end.
+
Index: components/lazutils/utf8process.pp
===================================================================
--- components/lazutils/utf8process.pp	(revision 55266)
+++ components/lazutils/utf8process.pp	(working copy)
@@ -359,7 +359,8 @@
 Const
   PriorityConstants : Array [TProcessPriority] of Cardinal =
                       (HIGH_PRIORITY_CLASS,IDLE_PRIORITY_CLASS,
-                       NORMAL_PRIORITY_CLASS,REALTIME_PRIORITY_CLASS);
+                       NORMAL_PRIORITY_CLASS,REALTIME_PRIORITY_CLASS,
+                       BELOW_NORMAL_PRIORITY_CLASS,ABOVE_NORMAL_PRIORITY_CLASS);
 
 function WStrAsUniquePWideChar(var s: UnicodeString): PWideChar; inline;
 begin
Index: components/lazutils/winlazfileutils.inc
===================================================================
--- components/lazutils/winlazfileutils.inc	(revision 55266)
+++ components/lazutils/winlazfileutils.inc	(working copy)
@@ -267,7 +267,7 @@
   {$IFDEF ACP_RTL}
   f.Name:=String(UnicodeString(F.FindData.cFileName));
   {$ELSE}
-  f.Name:=UTF8Encode(UnicodeString(F.FindData.cFileName));
+  f.Name:=pchar(UTF8Encode(UnicodeString(F.FindData.cFileName)));
   {$ENDIF}
   {$else}
   f.Name:=F.FindData.cFileName;
Index: components/synedit/synedit.inc
===================================================================
--- components/synedit/synedit.inc	(revision 55266)
+++ components/synedit/synedit.inc	(working copy)
@@ -41,6 +41,8 @@
 // support for multibyte character sets
 {.$DEFINE SYN_MBCSSUPPORT}
 
+{$define SynForceDoubeWidthHack}
+
 // additional tests for debugging
 
 {.$DEFINE SYN_DEVELOPMENT_CHECKS}
Index: components/synedit/synedit.pp
===================================================================
--- components/synedit/synedit.pp	(revision 55266)
+++ components/synedit/synedit.pp	(working copy)
@@ -1205,6 +1205,10 @@
     property OnSpecialLineColors: TSpecialLineColorsEvent read FOnSpecialLineColors write SetSpecialLineColors;  deprecated;
     property OnSpecialLineMarkup: TSpecialLineMarkupEvent read FOnSpecialLineMarkup write SetSpecialLineMarkup;
     property OnStatusChange: TStatusChangeEvent read fOnStatusChange write fOnStatusChange;
+{$ifdef LCLGtk2}
+  protected
+    procedure GTK_IMComposition(var Message:TMessage); message LM_IM_COMPOSITION;
+{$endif}
   end;
 
   TSynEdit = class(TCustomSynEdit)
@@ -4235,6 +4239,26 @@
   Result := FMarkupManager.Count;
 end;
 
+{$ifdef LCLGtk2}
+procedure TCustomSynEdit.GTK_IMComposition(var Message: TMessage);
+var
+  IMStr:TUTF8Char;
+begin
+  if (not ReadOnly) then
+  begin
+    // delete previous character by selection
+    if Message.WParam and GTK_IM_FLAG_REPLACE<>0 then
+      CommandProcessor(ecSelLeft,#0,nil);
+    // valid string at composition & commit
+    if Message.WParam and (GTK_IM_FLAG_START or GTK_IM_FLAG_END)=0 then
+    begin
+      IMStr:=pchar(Message.LParam);
+      UTF8KeyPress(IMStr);
+    end;
+  end;
+end;
+{$endif}
+
 procedure TCustomSynEdit.SetCaretTypeSize(AType: TSynCaretType; AWidth, AHeight, AXOffs,
   AYOffs: Integer);
 begin
Index: lcl/interfaces/gtk2/gtk2globals.pp
===================================================================
--- lcl/interfaces/gtk2/gtk2globals.pp	(revision 55266)
+++ lcl/interfaces/gtk2/gtk2globals.pp	(working copy)
@@ -64,6 +64,8 @@
   im_context: PGtkIMContext = nil;
   im_context_widget: PGtkWidget = nil;
   im_context_string: string = '';
+  im_context_use: Boolean = False; //DW
+  im_context_skipDelete: Boolean = False;
 
 procedure ResetDefaultIMContext;
 
@@ -408,6 +410,8 @@
   end;
   im_context_widget:=nil;
   im_context_string:='';
+  im_context_use:=False; //DW
+  im_context_skipDelete:=False;
 end;
 
 procedure AddCharsetEncoding(CharSet: Byte; CharSetReg, CharSetCod: CharSetStr;
Index: lcl/interfaces/gtk2/gtk2proc.inc
===================================================================
--- lcl/interfaces/gtk2/gtk2proc.inc	(revision 55266)
+++ lcl/interfaces/gtk2/gtk2proc.inc	(working copy)
@@ -2000,7 +2000,8 @@
       end;
       Exit;
     end;
-    Result := (AEvent^.Length > 0) or (GetSpecialChar <> #0);
+    //DW
+    Result := ((not im_context_use) and (AEvent^.Length > 0)) or (GetSpecialChar <> #0);
   end;
   
   function KeyAlreadyHandledByGtk: boolean;
@@ -2007,7 +2008,7 @@
   begin
     Result := false;
     if AWidget = nil then exit;
-    
+
     if GtkWidgetIsA(AWidget, gtk_entry_get_type)
     then begin
       // the gtk_entry handles the following keys
@@ -2368,7 +2369,7 @@
 
       Msg.KeyData := CommonKeyData or (Flags shl 16) or $0001 {TODO:  repeatcount};
 
-      if not KeyAlreadyHandledByGtk
+      if (not KeyAlreadyHandledByGtk) and (not im_context_use)
       then begin
         // send the (Sys)KeyDown message directly to the LCL
         NotifyApplicationUserInput(TControl(TargetObj), Msg.Msg);
@@ -2440,7 +2441,10 @@
         begin
           OldCharacter := Character;
           // send the key after navigation keys were handled
-          Result := TWinControl(LCLObject).IntfUTF8KeyPress(Character, 1, SysKey);
+          if not im_context_use then
+            Result := TWinControl(LCLObject).IntfUTF8KeyPress(Character, 1, SysKey)
+            else
+              Result:=True;
           if Result or (Character = '') then
             // dont' stop key event here, just clear it since we need a keyUp event
             ClearKey
Index: lcl/interfaces/gtk2/gtk2widgetset.inc
===================================================================
--- lcl/interfaces/gtk2/gtk2widgetset.inc	(revision 55266)
+++ lcl/interfaces/gtk2/gtk2widgetset.inc	(working copy)
@@ -215,12 +215,89 @@
 end;
 
 procedure gtk_commit_cb ({%H-}context: PGtkIMContext; const Str: Pgchar;
-  {%H-}Data: Pointer); cdecl;
+   {%H-}Data: Pointer); cdecl;
+var
+  Control:TWinControl;
+  Flag:WPARAM;
 begin
   //DebugLn(['gtk_commit_cb ',dbgstr(Str),'="',Str,'"']);
   im_context_string:=Str;
+  { Handle commit string at ending composition,
+    it cannot handled by HandleGTKKeyUpDown }
+  if im_context_use and (im_context_widget<>nil) and (im_context_string<>'') and
+     gtk_widget_is_focus(im_context_widget) then
+      begin
+        Control:=TWinControl(GetNearestLCLObject(im_context_widget));
+        Flag:=GTK_IM_FLAG_COMMIT;
+        if not im_context_skipDelete then
+          Flag:=Flag or GTK_IM_FLAG_REPLACE;
+        SendMessage(Control.Handle,LM_IM_COMPOSITION,Flag,LPARAM(pchar(im_context_string)));
+        im_context_string:='';
+        im_context_skipDelete:=True;
+      end;
 end;
 
+procedure gtk_preedit_start_cb({%H-}context: PGtkIMContext; {%H-}Data: Pointer); cdecl;
+var
+  control:TWinControl;
+  Flag:WPARAM;
+begin
+  if (im_context_widget<>nil) and
+     (gtk_widget_is_focus(im_context_widget)) and
+     (GetNearestLCLObject(im_context_widget) is TCustomControl) then
+  begin
+    im_context_use:=True;
+    im_context_skipDelete:=True;
+    control:=TWinControl(GetNearestLCLObject(im_context_widget));
+    Flag:=GTK_IM_FLAG_START;
+    SendMessage(Control.Handle,LM_IM_COMPOSITION,Flag,LPARAM(Data));
+  end else
+    im_context_use:=False;
+end;
+
+procedure gtk_preedit_end_cb({%H-}context: PGtkIMContext; {%H-}Data: Pointer); cdecl;
+var
+  control:TWinControl;
+  Flag:WPARAM;
+begin
+  im_context_use:=False;
+  if (im_context_widget<>nil) and
+     (gtk_widget_is_focus(im_context_widget)) and
+     (GetNearestLCLObject(im_context_widget) is TCustomControl) then
+  begin
+    im_context_skipDelete:=True;
+    control:=TWinControl(GetNearestLCLObject(im_context_widget));
+    Flag:=GTK_IM_FLAG_END;
+    SendMessage(control.Handle,LM_IM_COMPOSITION,Flag,LPARAM(Data));
+  end;
+end;
+
+procedure gtk_preedit_changed_cb({%H-}context:PGtkIMContext; {%H-}Data:Pointer); cdecl;
+var
+  str:Pgchar;
+  pangoattr:PPangoAttrList;
+  pos:gint;
+  control:TWinControl;
+  Flag:WPARAM;
+begin
+  if im_context_use and (im_context_widget<>nil) and
+    gtk_widget_is_focus(im_context_widget) then
+  begin
+    control:=TWinControl(GetNearestLCLObject(im_context_widget));
+    pos:=1;
+    gtk_im_context_get_preedit_string(context,@str,pangoattr,@pos);
+    im_context_string:=str;
+    g_free(str);
+    pango_attr_list_unref(pangoattr);
+    Flag:=GTK_IM_FLAG_COMPOSITION;
+    if (not im_context_skipDelete) and (Length(im_context_string)>0) then begin
+      Flag:=Flag or GTK_IM_FLAG_REPLACE;
+    end else
+      im_context_skipDelete:=False;
+    SendMessage(control.Handle,LM_IM_COMPOSITION,Flag,LPARAM(pchar(im_context_string)));
+  end;
+end;
+
 {------------------------------------------------------------------------------
   Function: TGtk2WidgetSet._SetCallbackEx
 
@@ -963,6 +1040,13 @@
   im_context:=gtk_im_multicontext_new;
   g_signal_connect (G_OBJECT (im_context), 'commit',
     G_CALLBACK (@gtk_commit_cb), nil);
+  //DW
+  g_signal_connect (G_OBJECT (im_context), 'preedit-start',
+    G_CALLBACK (@gtk_preedit_start_cb), nil);
+  g_signal_connect (G_OBJECT (im_context), 'preedit-end',
+    G_CALLBACK (@gtk_preedit_end_cb), nil);
+  g_signal_connect (G_OBJECT (im_context), 'preedit-changed',
+    G_CALLBACK (@gtk_preedit_changed_cb), nil);
   {$IFDEF HASX}
   if IsNoTransientWM then
   begin
Index: lcl/interfaces/win32/win32callback.inc
===================================================================
--- lcl/interfaces/win32/win32callback.inc	(revision 55266)
+++ lcl/interfaces/win32/win32callback.inc	(working copy)
@@ -1386,6 +1386,16 @@
       Area := PDrawIS^.rcItem;
       ItemState := TOwnerDrawState(PDrawIS^.itemState);
       DC := PDrawIS^._hDC;
+      // odFocused on enter control didn't fired with ODA_DRAWENTIRE
+      if (PDrawItemStruct(LParam)^.itemAction and ODA_DRAWENTIRE)<>0 then 
+      begin
+        if lWinControl.Focused and not (odFocused in ItemState) then
+           if ((lWinControl is TCustomListBox)
+               and (TCustomListBox(lWinControl).ItemIndex=ItemID)) or
+              ((lWinControl is TCustomComboBox)
+               and (TCustomComboBox(lWinControl).ItemIndex=ItemID)) then
+                  Include(ItemState,odFocused);
+      end;
     end;
     if (aMsg = LM_DRAWLISTITEM) and (WindowInfo <> @DefaultWindowInfo) then
     begin
Index: lcl/interfaces/win32/win32memostrings.inc
===================================================================
--- lcl/interfaces/win32/win32memostrings.inc	(revision 55266)
+++ lcl/interfaces/win32/win32memostrings.inc	(working copy)
@@ -134,7 +134,7 @@
 procedure TWin32MemoStrings.Insert(Index: integer; const S: string);
 var
   LineStart, RealCount: Integer;
-  NewLine: String;
+  NewLine: string;
 begin
   RealCount := GetRealCount;
   if Index < RealCount then
@@ -141,7 +141,7 @@
   begin
     //insert with LineEnding
     LineStart := GetLineStart(Index);
-    NewLine := S+LineEnding;
+    NewLine := pchar(S)+LineEnding;
     SendMessageW(FHandle, EM_SETSEL, LineStart, LineStart);
     SendMessageW(FHandle, EM_REPLACESEL, 0, lparam(PWideChar(UTF8ToUTF16(NewLine))));
   end
Index: lcl/lcltranslator.pas
===================================================================
--- lcl/lcltranslator.pas	(revision 55266)
+++ lcl/lcltranslator.pas	(working copy)
@@ -104,7 +104,7 @@
 
     if LangID <> '' then
     begin
-      AppDir := ExtractFilePath(ParamStrUTF8(0));
+      AppDir := pchar(ExtractFilePath(ParamStrUTF8(0)));
       LCFileName := ChangeFileExt(ExtractFileName(ParamStrUTF8(0)), LCExt);
       FullLCFileName := ChangeFileExt(ExtractFileName(ParamStrUTF8(0)), '.' + LangID) + LCExt;
 
Index: lcl/lmessages.pp
===================================================================
--- lcl/lmessages.pp	(revision 55266)
+++ lcl/lmessages.pp	(working copy)
@@ -96,7 +96,15 @@
   LM_INTERFACELAST  = LM_LCL + 199;
   
   LM_UNKNOWN        = LM_INTERFACELAST + 1;
+  LM_IM_COMPOSITION = LM_UNKNOWN + 1; // gtk IM
 
+  // GTK IM Flags
+  GTK_IM_FLAG_START       = 1;
+  GTK_IM_FLAG_COMPOSITION = 2;
+  GTK_IM_FLAG_END         = 4;
+  GTK_IM_FLAG_COMMIT      = 8;
+  GTK_IM_FLAG_REPLACE     = 16;
+
   //-------------
   //end of messages that are sent to the interface
   //-------------
Index: lcl/xmlpropstorage.pas
===================================================================
--- lcl/xmlpropstorage.pas	(revision 55266)
+++ lcl/xmlpropstorage.pas	(working copy)
@@ -180,7 +180,7 @@
   Res: UnicodeString;
 begin
   Res:=FXML.GetValue(Utf8Decode(FixPath(Section)+'/'+Ident), Utf8Decode(TheDefault));
-  Result := Utf8Encode(Res);
+  Result := PChar(Utf8Encode(Res));
   //debugln('TCustomXMLPropStorage.DoReadString Section="',Section,'" Ident="',Ident,'" Result=',Result);
 end;
 
Index: tools/svn2revisioninc.pas
===================================================================
--- tools/svn2revisioninc.pas	(revision 55266)
+++ tools/svn2revisioninc.pas	(working copy)
@@ -281,12 +281,25 @@
     SvnVersionProcess: TProcessUTF8;
     Buffer: string;
     n: LongInt;
+    {$ifdef windows}
+    svnpath : string;
+    {$endif}
   begin
     Result:=false;
     SvnVersionProcess := TProcessUTF8.Create(nil);
     try
       with SvnVersionProcess do begin
+      {$ifdef Windows}
+        svnpath := GetEnvironmentVariableUTF8('FPC_SVN_PATH')+PathDelim+'svnversion';
+        if not FileExistsUTF8(svnpath+'.exe') then begin
+          svnpath := '..\..\fpcbootstrap\svn\bin\svnversion';
+            if not FileExistsUTF8(svnpath+'.exe') then
+               svnpath := 'svnversion';
+        end;
+        CommandLine := svnpath+' -n "' + SourceDirectory + '"';
+      {$else}
         CommandLine := 'svnversion -n "' + SourceDirectory + '"';
+      {$endif}
         Options := [poUsePipes, poWaitOnExit];
         try
           Execute;
