Index: compiler/nadd.pas
===================================================================
--- compiler/nadd.pas	(revision 32121)
+++ compiler/nadd.pas	(working copy)
@@ -2234,6 +2234,56 @@
         tempnode (*,tempnode2*) : ttempcreatenode;
         cmpfuncname: string;
         para: tcallparanode;
+        newencoding: tstringencoding;
+        
+        procedure checkencodingnode(hn:tnode);
+        var
+          hp, hp3: tnode;
+        begin
+          hp:=hn;
+          if assigned(hp) then
+          begin
+            if hp.nodetype=blockn then
+            begin
+              hp3:=tblocknode(hp).statements;
+              repeat
+                hp:=tstatementnode(hp3).statement;
+                checkencodingnode(hp);
+                hp3:=tstatementnode(hp3).next;
+              until assigned(hp3);
+            end else
+            if (hp.nodetype=typeconvn) and 
+                assigned(ttypeconvnode(hp).resultdef) and
+                (ttypeconvnode(hp).resultdef.typ=stringdef) then 
+            begin
+              if assigned(ttypeconvnode(hp).left) and 
+                 (ttypeconvnode(hp).left.nodetype=addn) and
+                 assigned(taddnode(ttypeconvnode(hp).left).resultdef) and
+                 (taddnode(ttypeconvnode(hp).left).resultdef.typ=stringdef) and
+                 taddnode(ttypeconvnode(hp).left).isequal(self) then
+              begin
+                if assigned(ttypeconvnode(hp).totypedef) and 
+                  (tstringdef(ttypeconvnode(hp).totypedef).stringtype=st_ansistring) then
+                  newencoding:=tstringdef(ttypeconvnode(hp).totypedef).encoding;
+              end;
+            end;
+            if hp is tbinarynode then
+            begin
+              checkencodingnode(tbinarynode(hp).left);
+              checkencodingnode(tbinarynode(hp).right);
+            end else
+            if hp is tunarynode then
+              checkencodingnode(tunarynode(hp).left);
+          end;
+        end;
+
+        procedure encodingfromtypeconv;
+        begin
+            if assigned(aktassignmentnode) then
+              if assigned(aktassignmentnode.left) and (aktassignmentnode.left.resultdef.typ=stringdef) then               
+                  checkencodingnode(aktassignmentnode.right);
+        end;
+      
       begin
         result:=nil;
         { when we get here, we are sure that both the left and the right }
@@ -2271,16 +2321,20 @@
                           )
                         );
                   if is_ansistring(resultdef) then
+                  begin
+                    newencoding:=tstringdef(resultdef).encoding;
+                    encodingfromtypeconv;
                     para:=ccallparanode.create(
                             cordconstnode.create(
                               { don't use getparaencoding(), we have to know
                                 when the result is rawbytestring }
-                              tstringdef(resultdef).encoding,
+                              newencoding,
                               u16inttype,
                               true
                             ),
                             para
                           );
+                  end;
                   result:=ccallnode.createintern(
                             'fpc_'+tstringdef(resultdef).stringtypname+'_concat',
                             para
@@ -2311,16 +2365,21 @@
                           )
                         );
                   if is_ansistring(resultdef) then
+                  begin
+                    { assign typeconvnode encoding to addnode encoding }
+                    newencoding:=tstringdef(resultdef).encoding;
+                    encodingfromtypeconv;
                     para:=ccallparanode.create(
                             cordconstnode.create(
                               { don't use getparaencoding(), we have to know
                                 when the result is rawbytestring }
-                              tstringdef(resultdef).encoding,
+                              newencoding,
                               u16inttype,
                               true
                             ),
                             para
                           );
+                  end;
                   addstatement(
                     newstatement,
                     ccallnode.createintern(
Index: compiler/nopt.pas
===================================================================
--- compiler/nopt.pas	(revision 32121)
+++ compiler/nopt.pas	(working copy)
@@ -312,6 +312,55 @@
   tempnode    : ttempcreatenode;
   is_shortstr : boolean;
   para : tcallparanode;
+  newencoding: tstringencoding;
+
+    procedure checkencodingnode_multi(hn:tnode);
+    var
+      hp1, hp3: tnode;
+    begin
+      hp1:=hn;
+      if assigned(hp1) then
+      begin
+        if hp1.nodetype=blockn then
+        begin
+          hp3:=tblocknode(hp1).statements;
+          repeat
+            hp1:=tstatementnode(hp3).statement;
+            checkencodingnode_multi(hp1);
+            hp3:=tstatementnode(hp3).next;
+          until assigned(hp3);
+        end else
+        if (hp1.nodetype=typeconvn) and 
+            assigned(ttypeconvnode(hp1).resultdef) and
+            (ttypeconvnode(hp1).resultdef.typ=stringdef) then 
+        begin
+          if assigned(ttypeconvnode(hp1).left) and 
+             (ttypeconvnode(hp1).left.nodetype=addn) and
+             assigned(taddnode(ttypeconvnode(hp1).left).resultdef) and
+             (taddnode(ttypeconvnode(hp1).left).resultdef.typ=stringdef) and
+             taddnode(ttypeconvnode(hp1).left).isequal(p) then
+          begin
+            if assigned(ttypeconvnode(hp1).totypedef) and 
+              (tstringdef(ttypeconvnode(hp1).totypedef).stringtype=st_ansistring) then
+              newencoding:=tstringdef(ttypeconvnode(hp1).totypedef).encoding;
+          end;
+        end;
+        if hp1 is tbinarynode then
+        begin
+          checkencodingnode_multi(tbinarynode(hp1).left);
+          checkencodingnode_multi(tbinarynode(hp1).right);
+        end else
+        if hp1 is tunarynode then
+          checkencodingnode_multi(tunarynode(hp1).left);
+      end;
+    end;
+
+    procedure encodingfromtypeconv_multi;
+    begin
+        if assigned(aktassignmentnode) then
+          if assigned(aktassignmentnode.left) and (aktassignmentnode.left.resultdef.typ=stringdef) then               
+              checkencodingnode_multi(aktassignmentnode.right);
+    end;
 begin
   arrp:=nil;
   hp:=p;
@@ -347,16 +396,20 @@
               ccallparanode.create(aktassignmentnode.left.getcopy,nil)
             );
       if is_ansistring(p.resultdef) then
+      begin
+        newencoding:=tstringdef(p.resultdef).encoding;
+        encodingfromtypeconv_multi;
         para:=ccallparanode.create(
                 cordconstnode.create(
                   { don't use getparaencoding(), we have to know
                     when the result is rawbytestring }
-                  tstringdef(p.resultdef).encoding,
+                  newencoding,
                   u16inttype,
                   true
                 ),
                 para
               );
+      end;
       result:=ccallnode.createintern(
                 'fpc_'+tstringdef(p.resultdef).stringtypname+'_concat_multi',
                 para
@@ -383,16 +436,21 @@
               ccallparanode.create(ctemprefnode.create(tempnode),nil)
             );
       if is_ansistring(p.resultdef) then
+      begin
+        { assign typeconvnode encoding to addnode encoding }
+        newencoding:=tstringdef(p.resultdef).encoding;
+        encodingfromtypeconv_multi;
         para:=ccallparanode.create(
                 cordconstnode.create(
                   { don't use getparaencoding(), we have to know
                     when the result is rawbytestring }
-                  tstringdef(p.resultdef).encoding,
+                  newencoding,
                   u16inttype,
                   true
                 ),
                 para
               );
+      end;
       addstatement(
         newstatement,
         ccallnode.createintern(
Index: rtl/inc/astrings.inc
===================================================================
--- rtl/inc/astrings.inc	(revision 32121)
+++ rtl/inc/astrings.inc	(working copy)
@@ -215,8 +215,6 @@
 begin
 {$ifdef FPC_HAS_CPSTRING}
   DestCP:=cp;
-  if DestCp=CP_NONE then
-    DestCP:=DefaultSystemCodePage;
 {$else FPC_HAS_CPSTRING}
   DestCP:=StringCodePage(DestS);
 {$endif FPC_HAS_CPSTRING}
@@ -225,23 +223,25 @@
     but avoid conversions if either addend is empty (StringCodePage will return
     DefaultSystemCodePage in that case, which may differ from other addend/dest) }
   if S1='' then
+    {$ifdef FPC_HAS_CPSTRING}
+    S1CP:=DefaultSystemCodePage
+    {$else FPC_HAS_CPSTRING}
     S1CP:=DestCP
+    {$endif FPC_HAS_CPSTRING}
   else
     S1CP:=StringCodePage(S1);
   S1CP:=TranslatePlaceholderCP(S1CP);
   if S2='' then
+    {$ifdef FPC_HAS_CPSTRING}
+    S2CP:=DefaultSystemCodePage
+    {$else FPC_HAS_CPSTRING}
     S2CP:=DestCP
+    {$endif FPC_HAS_CPSTRING}
   else
     S2CP:=StringCodePage(S2);
   S2CP:=TranslatePlaceholderCP(S2CP);
-{$ifdef FPC_HAS_CPSTRING}
-  { if the result is rawbytestring and both strings have the same code page,
-    keep that code page }
-  if (cp=CP_NONE) and
-     (S1CP=S2CP) then
-    DestCP:=S1CP;
-{$endif FPC_HAS_CPSTRING}
-  if (S1CP<>DestCP) or (S2CP<>DestCP) then
+  { skip unicode conversion if dest encoding is CP_NONE }
+  if (DestCP<>CP_NONE) and ((S1CP<>DestCP) or (S2CP<>DestCP)) then
     begin
       ansistr_concat_complex(DestS,S1,S2,DestCP);
       exit;
@@ -281,6 +281,10 @@
       fpc_pchar_ansistr_intern_charmove(PAnsiChar(S1),0,DestS,0,S1Len);
       fpc_pchar_ansistr_intern_charmove(PAnsiChar(S2),0,DestS,S1Len,S2Len+1);
     end;
+  {$ifdef FPC_HAS_CPSTRING}
+  if DestCP=CP_NONE then
+    DestCP:=DefaultSystemCodePage;
+  {$endif FPC_HAS_CPSTRING}
   SetCodePage(DestS,DestCP,false);
 end;
 {$endif FPC_HAS_ANSISTR_CONCAT}
@@ -309,8 +313,6 @@
     end;
 {$ifdef FPC_HAS_CPSTRING}
   DestCP:=cp;
-  if DestCp=CP_NONE then
-    DestCP:=DefaultSystemCodePage;
 {$else FPC_HAS_CPSTRING}
   DestCP:=StringCodePage(DestS);
 {$endif FPC_HAS_CPSTRING}
@@ -326,6 +328,9 @@
     end;
   DestCP:=TranslatePlaceholderCP(DestCP);
   sameCP:=true;
+  { skip unicode conversion if dest encoding is CP_NONE }
+  if DestCP<>CP_NONE then
+  begin
   tmpCP:=TranslatePlaceholderCP(StringCodePage(sarr[lowstart]));
   for i:=lowstart+1 to high(sarr) do
     begin
@@ -338,6 +343,7 @@
           break;
         end;
     end;
+  end;
   if not sameCP then
     begin
       U:='';
@@ -349,12 +355,7 @@
       widestringmanager.Unicode2AnsiMoveProc(PUnicodeChar(Pointer(U)),DestS,DestCP,Length(U));
       exit;
     end;
-{$ifdef FPC_HAS_CPSTRING}
-  { if the result is rawbytestring and all strings have the same code page,
-    keep that code page }
-  if cp=CP_NONE then
-    DestCP:=tmpCP;
-{$endif FPC_HAS_CPSTRING}
+
   destcopy:=nil;
   nonemptystart:=lowstart;
   { Check for another reuse, then we can't use
@@ -401,7 +402,13 @@
           inc(pc,size);
         end;
     end;
-  SetCodePage(DestS,tmpCP,False);
+  if DestCP<>CP_NONE then
+  SetCodePage(DestS,tmpCP,False)
+  {$ifdef FPC_HAS_CPSTRING}
+    else
+      DestCP:=DefaultSystemCodePage
+  {$endif FPC_HAS_CPSTRING}
+    ;
   SetCodePage(DestS,DestCP,True);
   fpc_AnsiStr_Decr_Ref(destcopy);
 end;
